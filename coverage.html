
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>provider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rackdog/terraform-provider-rackdog/internal/provider/client.go (80.3%)</option>
				
				<option value="file1">github.com/rackdog/terraform-provider-rackdog/internal/provider/data_source_operating_systems.go (33.3%)</option>
				
				<option value="file2">github.com/rackdog/terraform-provider-rackdog/internal/provider/data_source_plans.go (12.0%)</option>
				
				<option value="file3">github.com/rackdog/terraform-provider-rackdog/internal/provider/provider.go (22.6%)</option>
				
				<option value="file4">github.com/rackdog/terraform-provider-rackdog/internal/provider/resource_server.go (1.0%)</option>
				
				<option value="file5">github.com/rackdog/terraform-provider-rackdog/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package provider

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"
)

type HTTPError struct {
        Status int
        Method string
        URL    string
        Body   string
}

func (e *HTTPError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s failed: %d - %s", e.Method, e.URL, e.Status, e.Body)
}</span>

type Client struct {
        base   string
        apiKey string
        http   *http.Client
}

func NewClient(base, apiKey string) *Client <span class="cov10" title="16">{
        return &amp;Client{
                base:   strings.TrimRight(base, "/"),
                apiKey: apiKey,
                http:   &amp;http.Client{Timeout: 30 * time.Second},
        }
}</span>

func (c *Client) do(ctx context.Context, method, path string, body any, out any) error <span class="cov9" title="12">{
        u := c.base + path

        var rdr io.Reader
        if body != nil </span><span class="cov1" title="1">{
                b, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">rdr = bytes.NewReader(b)</span>
        }

        <span class="cov9" title="12">req, err := http.NewRequestWithContext(ctx, method, u, rdr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Header name per your middleware note:
        <span class="cov9" title="12">req.Header.Set("x-rd-key", c.apiKey)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov9" title="12">defer resp.Body.Close()

        if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov8" title="11">{
                if out != nil </span><span class="cov8" title="10">{
                        return json.NewDecoder(resp.Body).Decode(out)
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov1" title="1">b, _ := io.ReadAll(resp.Body)
        return &amp;HTTPError{
                Status: resp.StatusCode,
                Method: method,
                URL:    u,
                Body:   string(b),
        }</span>
}

type JobStatus struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
}

type ServerOS struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
}

type ServerPlan struct {
        ID      int    `json:"id"`
        Name    string `json:"name"`
        RAMGB   int    `json:"ram"`
        Storage int    `json:"storage"`
        CPUName string `json:"cpuName"`
        Cores   int    `json:"cores"`
}

type ServerLocation struct {
        ID      int    `json:"id"`
        Name    string `json:"name"`
        Keyword string `json:"keyword"`
        Country string `json:"country"`
}

type CreateServerRequest struct {
        PlanID     int     `json:"planId"`
        LocationID int     `json:"locationId"`
        OSID       int     `json:"osId"`
        Raid       *int    `json:"raid,omitempty"`
        Hostname   *string `json:"hostname,omitempty"`
}

type Server struct {
        ID           string         `json:"id,omitempty"`
        Plan         ServerPlan     `json:"plan"`
        Location     ServerLocation `json:"location"`
        ServerOS     *ServerOS      `json:"serverOS,omitempty"`
        Raid         *int           `json:"raid,omitempty"`
        Hostname     *string        `json:"hostname,omitempty"`
        IPAddress    string         `json:"ipAddress,omitempty"`
        PowerStatus  *string        `json:"devicePowerStatus,omitempty"`
        MonthlyPrice *string        `json:"monthlyPrice,omitempty"`
}

type ServerListItem struct {
        ID          string  `json:"id,omitempty"`
        Hostname    *string `json:"hostname,omitempty"`
        IPAddress   string  `json:"ipAddress,omitempty"`
        PowerStatus *string `json:"powerStatus,omitempty"`
}

type CPU struct {
        Name  string  `json:"name"`
        Cores int     `json:"cores"`
        Speed float64 `json:"speedGhz"`
}

type PlanLocation struct {
        ID           int    `json:"id"`
        Name         string `json:"name"`
        Keyword      string `json:"keyword"`
        MonthlyPrice int    `json:"monthlyPrice"`
}

type Plan struct {
        ID        int            `json:"id"`
        Name      string         `json:"name"`
        CPU       CPU            `json:"cpu"`
        Locations []PlanLocation `json:"locations"`
        RAMGB     int            `json:"ram"`
        Storage   int            `json:"storageGb"`
}

// //////
// Responses from api
// //////
type EnvelopeServer struct {
        Success    bool   `json:"success"`
        Data       Server `json:"data"`
        Message    string `json:"message"`
        TotalCount int    `json:"totalCount,omitempty"`
}

type EnvelopeServerListItem struct {
        Success    bool           `json:"success"`
        Data       ServerListItem `json:"data"`
        Message    string         `json:"message"`
        TotalCount int            `json:"totalCount,omitempty"`
}

type EnvelopePlans struct {
        Success bool   `json:"success"`
        Data    []Plan `json:"data"`
        Message string `json:"message"`
}

type EnvelopeRaidCheck struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
}

type EnvelopeOS struct {
        Success bool       `json:"success"`
        Data    []ServerOS `json:"data"`
        Message string     `json:"message"`
}

func (c *Client) CreateServer(ctx context.Context, reqBody *CreateServerRequest) (*ServerListItem, error) <span class="cov1" title="1">{
        var env EnvelopeServerListItem
        if err := c.do(ctx, http.MethodPost, "/v1/ordering/allocate", reqBody, &amp;env); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if !env.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s", env.Message)
        }</span>
        <span class="cov1" title="1">out := env.Data
        return &amp;out, nil</span>
}

func (c *Client) GetServer(ctx context.Context, id string) (*Server, error) <span class="cov3" title="2">{
        var env EnvelopeServer
        if err := c.do(ctx, http.MethodGet, "/v1/servers/"+url.PathEscape(id), nil, &amp;env); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if !env.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s", env.Message)
        }</span>
        <span class="cov1" title="1">out := env.Data
        return &amp;out, nil</span>
}

func (c *Client) DeleteServer(ctx context.Context, id string) error <span class="cov1" title="1">{
        return c.do(ctx, http.MethodDelete, "/v1/servers/"+url.PathEscape(id)+"/destroy", nil, nil)
}</span>

func (c *Client) ListPlans(ctx context.Context, location string) ([]Plan, error) <span class="cov4" title="3">{
        var env EnvelopePlans
        path := "/v1/ordering/plans?showAll=true"
        if location != "" </span><span class="cov1" title="1">{
                path += "&amp;location=" + url.QueryEscape(location)
        }</span>
        <span class="cov4" title="3">if err := c.do(ctx, http.MethodGet, path, nil, &amp;env); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">if !env.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s", env.Message)
        }</span>
        <span class="cov4" title="3">return env.Data, nil</span>
}

func (c *Client) CheckRaid(ctx context.Context, raid int, planID int) (bool, error) <span class="cov3" title="2">{
        var env EnvelopeRaidCheck
        path := fmt.Sprintf("/v1/ordering/plans/%d/raid/%d/check", planID, raid)
        if err := c.do(ctx, http.MethodGet, path, nil, &amp;env); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov3" title="2">if !env.Success </span><span class="cov1" title="1">{
                return false, fmt.Errorf("%s", env.Message)
        }</span>
        <span class="cov1" title="1">return true, nil</span>
}

func (c *Client) ListOperatingSystems(ctx context.Context) ([]ServerOS, error) <span class="cov4" title="3">{
        var env EnvelopeOS
        if err := c.do(ctx, http.MethodGet, "/v1/ordering/os", nil, &amp;env); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">if !env.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s", env.Message)
        }</span>
        <span class="cov4" title="3">return env.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package provider

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

type osDataSource struct{ client *Client }

func NewOperatingSystemsDataSource() datasource.DataSource <span class="cov10" title="3">{ return &amp;osDataSource{} }</span>

type osModel struct {
        OperatingSystems []osItem `tfsdk:"operating_systems"`
}

type osItem struct {
        ID   types.Int64  `tfsdk:"id"`
        Name types.String `tfsdk:"name"`
}

func (d *osDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = req.ProviderTypeName + "_operating_systems"
}</span>

func (d *osDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov1" title="1">{
        resp.Schema = schema.Schema{
                Description: "Retrieves all available operating systems from Rackdog /ordering/os.",
                Attributes: map[string]schema.Attribute{
                        "operating_systems": schema.ListNestedAttribute{
                                Computed: true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "id":   schema.Int64Attribute{Computed: true},
                                                "name": schema.StringAttribute{Computed: true},
                                        },
                                },
                        },
                },
        }
}</span>

func (d *osDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) <span class="cov1" title="1">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">pd := req.ProviderData.(*ProviderData)
        d.client = pd.Client</span>
}

func (d *osDataSource) Read(ctx context.Context, _ datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        if d.client == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Provider not configured", "Client was nil")
                return
        }</span>

        <span class="cov0" title="0">osList, err := d.client.ListOperatingSystems(ctx)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Failed to list operating systems", err.Error())
                return
        }</span>

        <span class="cov0" title="0">state := osModel{OperatingSystems: make([]osItem, 0, len(osList))}
        for _, o := range osList </span><span class="cov0" title="0">{
                state.OperatingSystems = append(state.OperatingSystems, osItem{
                        ID:   types.Int64Value(int64(o.ID)),
                        Name: types.StringValue(o.Name),
                })
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package provider

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

type plansDataSource struct{ client *Client }

func NewPlansDataSource() datasource.DataSource <span class="cov10" title="3">{ return &amp;plansDataSource{} }</span>

type plansModel struct {
        Location types.String `tfsdk:"location"`
        Plans    []planItem   `tfsdk:"plans"`
}

type planItem struct {
        ID      types.Int64  `tfsdk:"id"`
        Name    types.String `tfsdk:"name"`
        RAMGB   types.Int64  `tfsdk:"ram"`
        Storage types.Int64  `tfsdk:"storage"`
        CPUName types.String `tfsdk:"cpu_name"`
        Cores   types.Int64  `tfsdk:"cores"`
}

func (d *plansDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = req.ProviderTypeName + "_plans"
}</span>

func (d *plansDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov1" title="1">{
        resp.Schema = schema.Schema{
                Description: "Retrieves available hardware plans, optionally filtered by location keyword.",
                Attributes: map[string]schema.Attribute{
                        "location": schema.StringAttribute{Optional: true},
                        "plans": schema.ListNestedAttribute{
                                Computed: true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "id":       schema.Int64Attribute{Computed: true},
                                                "name":     schema.StringAttribute{Computed: true},
                                                "ram":      schema.Int64Attribute{Computed: true},
                                                "storage":  schema.Int64Attribute{Computed: true},
                                                "cpu_name": schema.StringAttribute{Computed: true},
                                                "cores":    schema.Int64Attribute{Computed: true},
                                        },
                                },
                        },
                },
        }
}</span>

func (d *plansDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">pd := req.ProviderData.(*ProviderData)
        d.client = pd.Client</span>
}

func (d *plansDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        if d.client == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Provider not configured", "Client was nil")
                return
        }</span>

        <span class="cov0" title="0">var config plansModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;config)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">loc := ""
        if !config.Location.IsNull() &amp;&amp; !config.Location.IsUnknown() </span><span class="cov0" title="0">{
                loc = config.Location.ValueString()
        }</span>

        <span class="cov0" title="0">plans, err := d.client.ListPlans(ctx, loc)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Failed to list plans", err.Error())
                return
        }</span>

        <span class="cov0" title="0">state := plansModel{Location: config.Location, Plans: make([]planItem, 0, len(plans))}
        for _, p := range plans </span><span class="cov0" title="0">{
                state.Plans = append(state.Plans, planItem{
                        ID:      types.Int64Value(int64(p.ID)),
                        Name:    types.StringValue(p.Name),
                        RAMGB:   types.Int64Value(int64(p.RAMGB)),
                        Storage: types.Int64Value(int64(p.Storage)),
                        CPUName: types.StringValue(p.CPU.Name),
                        Cores:   types.Int64Value(int64(p.CPU.Cores)),
                })
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package provider

import (
        "context"
        "os"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

type rackdogProvider struct {
        version string
}

func New(version string) func() provider.Provider <span class="cov10" title="5">{
        return func() provider.Provider </span><span class="cov10" title="5">{
                return &amp;rackdogProvider{version: version}
        }</span>
}

type providerModel struct {
        Endpoint          types.String `tfsdk:"endpoint"`
        APIKey            types.String `tfsdk:"api_key"`
        RecreateOnMissing types.Bool   `tfsdk:"recreate_on_missing"`
}

type resolvedConfig struct {
        RecreateOnMissing bool
}

type ProviderData struct {
        Client *Client
        Cfg    resolvedConfig
}

func (p *rackdogProvider) Metadata(_ context.Context, _ provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov1" title="1">{
        resp.TypeName = "rackdog"
        resp.Version = p.version
}</span>

func (p *rackdogProvider) Schema(_ context.Context, _ provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov4" title="2">{
        resp.Schema = schema.Schema{
                Description: "Provider for Rackdog infrastructure.",
                Attributes: map[string]schema.Attribute{
                        "endpoint": schema.StringAttribute{
                                Description: "Rackdog API base URL.",
                                Optional:    true,
                        },
                        "api_key": schema.StringAttribute{
                                Description: "API key for Rackdog.",
                                Optional:    true,
                                Sensitive:   true,
                        },
                        "recreate_on_missing": schema.BoolAttribute{
                                Optional:    true,
                                Description: "If true, resources missing on Read (404) will be removed from state so Terraform can recreate them.",
                        },
                },
        }
}</span>

func (p *rackdogProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov0" title="0">{
        var config providerModel
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;config)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">endpoint := getString(config.Endpoint, "RACKDOG_ENDPOINT", "https://metal.rackdog.com")
        key := getString(config.APIKey, "RACKDOG_API_KEY", "")
        if key == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Missing API Key", "No api_key or RACKDOG_API_KEY found.")
                return
        }</span>

        <span class="cov0" title="0">recreate := false
        if !config.RecreateOnMissing.IsNull() &amp;&amp; !config.RecreateOnMissing.IsUnknown() </span><span class="cov0" title="0">{
                recreate = config.RecreateOnMissing.ValueBool()
        }</span> else<span class="cov0" title="0"> if v := os.Getenv("RACKDOG_RECREATE_ON_MISSING"); v != "" </span><span class="cov0" title="0">{
                recreate = strings.EqualFold(v, "1") || strings.EqualFold(v, "true")
        }</span>

        <span class="cov0" title="0">client := NewClient(endpoint, key)
        pd := &amp;ProviderData{
                Client: client,
                Cfg:    resolvedConfig{RecreateOnMissing: recreate},
        }

        resp.DataSourceData = pd
        resp.ResourceData = pd

        tflog.Info(ctx, "Rackdog provider configured", map[string]any{
                "endpoint":            endpoint,
                "recreate_on_missing": recreate,
        })</span>
}

func (p *rackdogProvider) Resources(_ context.Context) []func() resource.Resource <span class="cov1" title="1">{
        return []func() resource.Resource{
                NewServerResource,
        }
}</span>

func (p *rackdogProvider) DataSources(_ context.Context) []func() datasource.DataSource <span class="cov1" title="1">{
        return []func() datasource.DataSource{
                NewPlansDataSource,
                NewOperatingSystemsDataSource,
        }
}</span>

func getString(v types.String, env, def string) string <span class="cov0" title="0">{
        if !v.IsNull() &amp;&amp; !v.IsUnknown() </span><span class="cov0" title="0">{
                return v.ValueString()
        }</span>
        <span class="cov0" title="0">if val := os.Getenv(env); val != "" </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return def</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package provider

import (
        "context"
        "errors"
        "net/http"

        "fmt"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

type serverResource struct {
        client *Client
        cfg    resolvedConfig
}

func NewServerResource() resource.Resource <span class="cov8" title="1">{ return &amp;serverResource{} }</span>

type serverModel struct {
        ID         types.String `tfsdk:"id"`
        PlanID     types.Int64  `tfsdk:"plan_id"`
        LocationID types.Int64  `tfsdk:"location_id"`
        OSID       types.Int64  `tfsdk:"os_id"`
        Raid       types.Int64  `tfsdk:"raid"`
        Hostname   types.String `tfsdk:"hostname"`
        IPAddress  types.String `tfsdk:"ip_address"`
        Status     types.String `tfsdk:"status"`
}

func (r *serverResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_server"
}</span>

func (r *serverResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                Description: "Manages Rackdog servers.",
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{Computed: true},
                        "plan_id": schema.Int64Attribute{
                                Required: true,
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "location_id": schema.Int64Attribute{
                                Required: true,
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "os_id": schema.Int64Attribute{
                                Required: true,
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "raid": schema.Int64Attribute{
                                Optional: true,
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "hostname": schema.StringAttribute{
                                Optional: true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "ip_address": schema.StringAttribute{
                                Computed: true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "status": schema.StringAttribute{Computed: true},
                },
        }
}</span>

func (r *serverResource) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) <span class="cov0" title="0">{
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">pd := req.ProviderData.(*ProviderData)
        r.client = pd.Client
        r.cfg = pd.Cfg</span>
}

func (r *serverResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Provider not configured", "Client was nil")
                return
        }</span>

        <span class="cov0" title="0">var plan serverModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;plan)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if !plan.Raid.IsNull() &amp;&amp; !plan.Raid.IsUnknown() </span><span class="cov0" title="0">{
                ok, err := r.client.CheckRaid(ctx, int(plan.Raid.ValueInt64()), int(plan.PlanID.ValueInt64()))
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError("RAID validation failed", err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError("Invalid RAID for plan",
                                "Selected RAID level is not available for the chosen plan. Choose a supported RAID or omit it.")
                        return
                }</span>
        }

        <span class="cov0" title="0">in := &amp;CreateServerRequest{
                PlanID:     int(plan.PlanID.ValueInt64()),
                LocationID: int(plan.LocationID.ValueInt64()),
                OSID:       int(plan.OSID.ValueInt64()),
        }
        if !plan.Raid.IsNull() &amp;&amp; !plan.Raid.IsUnknown() </span><span class="cov0" title="0">{
                rv := int(plan.Raid.ValueInt64())
                in.Raid = &amp;rv
        }</span>
        <span class="cov0" title="0">if !plan.Hostname.IsNull() &amp;&amp; !plan.Hostname.IsUnknown() </span><span class="cov0" title="0">{
                h := plan.Hostname.ValueString()
                in.Hostname = &amp;h
        }</span>

        <span class="cov0" title="0">created, err := r.client.CreateServer(ctx, in)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Create failed", err.Error())
                return
        }</span>

        <span class="cov0" title="0">plan.ID = types.StringValue(created.ID)
        if created.Hostname != nil </span><span class="cov0" title="0">{
                plan.Hostname = types.StringValue(*created.Hostname)
        }</span>
        <span class="cov0" title="0">plan.IPAddress = types.StringValue(created.IPAddress)
        plan.Status = types.StringNull()

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;plan)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        //r.Read(ctx, resource.ReadRequest{State: resp.State}, &amp;resp.ReadResponse)
        <span class="cov0" title="0">return</span>
}

func (r *serverResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Provider not configured", "Client was nil")
                return
        }</span>

        <span class="cov0" title="0">var state serverModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s, err := r.client.GetServer(ctx, state.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                var he *HTTPError
                if errors.As(err, &amp;he) &amp;&amp; he.Status == http.StatusNotFound </span><span class="cov0" title="0">{
                        if !r.cfg.RecreateOnMissing </span><span class="cov0" title="0">{
                                resp.Diagnostics.AddError(
                                        "Server deleted outside Terraform",
                                        "The server no longer exists (404) and provider setting `recreate_on_missing` is false. "+
                                                "Enable it in the provider or import an existing server by ID.",
                                )
                                return
                        }</span>
                        <span class="cov0" title="0">resp.State.RemoveResource(ctx) // lenient: allow plan to recreate
                        return</span>
                }
                <span class="cov0" title="0">resp.Diagnostics.AddError("Read failed", err.Error())
                return</span>
        }
        <span class="cov0" title="0">if s == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Server missing", "API returned no error but also no server")
                return
        }</span>

        <span class="cov0" title="0">if !state.Hostname.IsNull() &amp;&amp; s.Hostname != nil &amp;&amp; state.Hostname.ValueString() != *s.Hostname </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Out-of-band change detected (hostname)",
                        fmt.Sprintf("Remote hostname is %q but state expected %q. This likely happened outside Terraform (portal/api). "+
                                "Please reconcile: either update your config to match, import the correct resource, or replace this server.",
                                *s.Hostname, state.Hostname.ValueString()),
                )
                return
        }</span>

        <span class="cov0" title="0">if s.Plan.ID != 0 &amp;&amp; state.PlanID.ValueInt64() != 0 </span><span class="cov0" title="0">{
                if state.PlanID.ValueInt64() != int64(s.Plan.ID) </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Out-of-band change detected (plan_id)",
                                "Remote plan differs from state; reconcile manually and re-run.",
                        )
                        return
                }</span>
        }

        <span class="cov0" title="0">if s.Location.ID != 0 &amp;&amp; state.LocationID.ValueInt64() != 0 </span><span class="cov0" title="0">{
                if state.LocationID.ValueInt64() != int64(s.Location.ID) </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Out-of-band change detected (location_id)",
                                "Remote location differs from state; reconcile manually and re-run.",
                        )
                        return
                }</span>
        }

        <span class="cov0" title="0">if s.ServerOS != nil &amp;&amp; state.OSID.ValueInt64() != 0 </span><span class="cov0" title="0">{
                if int64(s.ServerOS.ID) != state.OSID.ValueInt64() </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Out-of-band change detected (os_id)",
                                "Remote OS differs from state; reconcile manually and re-run.",
                        )
                        return
                }</span>
        }

        <span class="cov0" title="0">if s.Raid != nil &amp;&amp; !state.Raid.IsNull() &amp;&amp; !state.Raid.IsUnknown() </span><span class="cov0" title="0">{
                if int(state.Raid.ValueInt64()) != *s.Raid </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Out-of-band change detected (raid)",
                                "Remote RAID differs from state; reconcile manually and re-run.",
                        )
                        return
                }</span>
        }

        <span class="cov0" title="0">state.IPAddress = types.StringValue(s.IPAddress)
        if s.Hostname != nil </span><span class="cov0" title="0">{
                state.Hostname = types.StringValue(*s.Hostname)
        }</span>
        <span class="cov0" title="0">if s.PowerStatus != nil </span><span class="cov0" title="0">{
                state.Status = types.StringValue(*s.PowerStatus)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *serverResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        resp.Diagnostics.AddWarning("No Update implemented", "Rackdog servers cannot be updated.")
}</span>

func (r *serverResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        if r.client == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Provider not configured", "Client was nil")
                return
        }</span>

        <span class="cov0" title="0">var state serverModel
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := r.client.DeleteServer(ctx, state.ID.ValueString()); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Delete failed", err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "flag"
        "github.com/hashicorp/terraform-plugin-framework/providerserver"
        "github.com/hashicorp/terraform-plugin-log/tflog"
        "github.com/rackdog/terraform-provider-rackdog/internal/provider"
)

var version = "dev"

func main() <span class="cov0" title="0">{
        debug := flag.Bool("debug", false, "Enable debug logging")
        flag.Parse()

        ctx := context.Background()

        if *debug </span><span class="cov0" title="0">{
                tflog.Info(ctx, "Debug logging enabled")
        }</span>

        <span class="cov0" title="0">providerserver.Serve(ctx, provider.New(version), providerserver.ServeOpts{
                Address: "registry.terraform.io/rackdog/rackdog",
        })</span>

}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
